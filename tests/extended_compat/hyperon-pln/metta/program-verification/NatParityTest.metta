;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Example of using MeTTa to prove properties, here evenness, over
;; programs, here a doubling function.
;;
;; That file contains a backward chainer running on a logic including
;; equality, natural numbers, structural induction, dependent sum, the
;; even property and the double function over natural numbers, and
;; proves that doubling any natural number results into an even
;; number.
;;
;; Some remarks:
;;
;; To not interfere with MeTTa built-in type checker, naturals are
;; redefined with other symbols in the knowledge base handed to the
;; backward chainer.  Specifically Nat becomes â„•, Z becomes ğ™ and S
;; becomes ğ’.  For that and other symbols, your editor needs to
;; support unicodes.
;;
;; To not be confused with MeTTa variables (starting with $),
;; variables defined by lambda abstractions are De Bruijn indices with
;; the following syntax: the zero index is represented by z, the
;; successor index function is represented by s.
;;
;; In order for the backward chainer to support lambda abstraction,
;; the terms must be fully annotated, for instance
;;
;; (S Z)
;;
;; becomes
;;
;; (: (S (: Z â„•)) â„•)
;;
;; We do intend to develop a version of the backward chainer that does
;; not require full type annotation, in the meantime you can use the
;; functions add-type-annotation and remove-type-annotation to add and
;; remove type annotations from terms.
;;
;; To speed up the backward chainer, reduction rules can be used,
;; however due to a current limitation of MeTTa (see
;; https://github.com/trueagi-io/hyperon-experimental/issues/674) only
;; a tiny subset is used in that experiment.
;;
;; The dependent sum (aka sigma type) representation is borrowed from
;; https://idris2.readthedocs.io/en/latest/tutorial/typesfuns.html#dependent-pairs
;;
;; The structural induction rule is slightly tailored for that
;; specific problem by requiring that the property be expressed as the
;; composition of two functions.  We intend to remedy that in the
;; future.
;;
;; Running the whole file takes about 1h30 on an Intel i9-10940X.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define <=
(: <= (-> $a $a Bool))
(= (<= $x $y) (or (< $x $y) (== $x $y)))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: z DeBruijn)                        ; Zero
(: s (-> DeBruijn DeBruijn))          ; Successor

;;;;;;;;;;
;; List ;;
;;;;;;;;;;

;; Declaration of List data type and constructors
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;;;;;;;;;;;;;;;;;;;;;
;; Match over list ;;
;;;;;;;;;;;;;;;;;;;;;

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

;; Test match' on empty list
!(assertEqualToResult
  (match' Nil ($x $y) ($y $x))
  ())

;; Test match' on singleton
!(assertEqual
  (match' (Cons (A B) Nil) ($x $y) ($y $x))
  (B A))

;; Test match' on pair
!(assertEqualToResult
  (match' (Cons (A B) (Cons (C D) Nil)) ($x $y) ($y $x))
  ((B A)
   (D C)))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Curried Backward Chainer with lambda abstraction and dependent
;; types.  A lambda abstraction is represented by
;;
;; (Î» <INDEX> <BODY>)
;;
;; where <INDEX> is a De Bruijn index as define above, such as z or
;; (s z), and <BODY> is a term possibly containing <INDEX>.  Note
;; that the use of De Bruijn index in lambda abstraction is somewhat
;; unconventional here.  It differs from what is described in
;; https://en.wikipedia.org/wiki/De_Bruijn_index in three ways:
;;
;; 1. The index is explicitely attached to a Î» by being its first
;;    argument.  For instance the lambda term Î»x.x, which would
;;    traditionally be represented by Î»1 using De Bruijn index, would
;;    be represented here by the MeTTa term (Î» z z).
;;
;; 2. As seen in the example above the index here starts at 0,
;;    represented by z, instead of 1.
;;
;; 3. The index increases as the lambda abstraction gets deeper.  For
;;    instance Î»x.Î»y.x, which would traditionally be represented by
;;    Î»Î»2 using De Bruijn index, is represented here by the MeTTa term
;;    (Î» z (Î» (s z) z).
;;
;; This differences are due to the way the proof abstraction recursive
;; step is defined in the bc, as well as the need for having non
;; overlapping pattern matching between the two recursive steps.
;; Specifically, if Î» had only one argument, then (Î» <BODY>) would
;; overlap with (<ABS> <ARG>).  Having Î» take 2 arguments instead of 1
;; has the disadvantage of making lambda abstraction not as compact.
;; On the flip side, the benefit is that the scope of an index is
;; easier to track.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Environment: a list of typing relationship between De Bruijn
;;   index and type, such as
;;
;;   (Cons (: z String) (Cons (: (s z) Number) Nil))
;;
;; * De Bruijn Index: De Bruijn Index to use if a lambda abstraction
;;   is introduced.
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.  Note that for arguments of
;;   applications must be type annotated (unknowns types are of course
;;   allowed).  For instance the following query
;;
;;   (: (ModusPonens ab) $thrm)
;;
;;   would not work, instead one needs to provide
;;
;;   (: (ModusPonens (: ab $lemma)) $thrm)
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
;;
;; As explained, the proof arguments must be type annotated.  Without
;; such type annotation, lambda abstraction sometimes leads to
;; incorrect results.  It is suspected to come from the fact that
;; otherwise the proof application recursive step loses bindings about
;; the premise.  Having annotated proof is however a good thing, to
;; display a proof tree and to have an indepth view into the proof.
;; In order to remove (resp. add) type annotation one can use
;; remove-type-annotation (resp. add-type).
(: bc (-> $a                            ; Knowledge base space
          (List $b)                     ; Environment
          DeBruijn                      ; De Bruijn Index
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))

;; TODO: proof abstraction is necessary for structural induction but
;; makes everything run much slower.  If your proof does not require
;; lambda abstraction, you can disable that definition, which should
;; result in a substantial speed-up.
;;
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (Î» $idx $prfbdy) (-> (: $idx $prms) $thrm)))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (s $idx) $k (: $prfbdy $thrm))
     (: (Î» $idx $prfbdy) (-> (: $idx $prms) $thrm))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge/rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;; The following code is translated into axioms and rules to handled
;; by the backward chainer.
;;
;; ;; Define Î£ type (called DPair in Idris)
;; (: Î£ (-> (: $a Type) (-> $a Type) Type))
;;
;; ;; Define DPair constructor
;; (: MkÎ£ (-> (: $p (-> $a Type)) (: $x $a) ($p $x) (Î£ $a $p)))
;;
;; ;; Define the even property
;; (: Even (-> Nat Type))
;; (: MkEvenZ (Even Z))
;; (: MkEvenSS (-> (Even $k) (Even (S (S $k)))))
;;
;; ;; Define examples of even numbers (0 and 2)
;; (: (MkÎ£ Even Z MkEvenZ) (Î£ Nat Even))
;; (: (MkÎ£ Even (S (S Z)) (MkEvenSS MkEvenZ)) (Î£ Nat Even))
;; (: $prf (Î£ Nat Even))
;;
;; ;; Define double function
;; (: double (-> Nat Nat))
;; (= (double Z) Z)
;; (= (double (S $k)) (S (S (double $k))))
;;
;; ;; Î£ access functions
;; (: Î£.val (-> (Î£ $a $p) $a))
;; (= (Î£.val (MkÎ£ $prop $val $prf)) $val)
;; (: Î£.prf (-> (Î£ $a $p) $p))
;; (= (Î£.prf (MkÎ£ $prop $val $prf)) $prf)
;;
;; ;; Define double function, with the guaranty that the output is even
;; (: doubleÎ£ (-> Nat (Î£ Nat Even)))
;; (= (doubleÎ£ Z) (MkÎ£ Even Z MkEvenZ))
;; (= (doubleÎ£ (S $k)) (MkÎ£ Even
;;                          (S (S (Î£.val (doubleÎ£ $k))))
;;                          (MkEvenSS (Î£.prf (doubleÎ£ $k)))))
;;
;; ;; For all x, (double x) is even
;; ;; âˆ€x (Even (double x))
;; (: double-even-prf (-> (: $x Nat) (Even (double $x))))
;;
;; ;; Independent product type (i.e. conjunction)
;; (: âŠ— (-> Type Type Type))
;;
;; ;; Equality
;; (: === (-> $a $a Type))
;;
;; ;; ;; TODO
;;
;; ;; ;; For all x, there exists k such that k = (double x) and k is even
;; ;; ;; âˆ€x âˆƒk k=(double x) âˆ§ (Even k)
;; ;; (: double-Î£-even-prf (-> ($x : Nat)
;; ;;                          (Î£ Nat (Î» $k (âŠ— (=== $k (double $x)) (Even $k))))))
;;
;; ;; (: double-Î£-even-prf (-> ($x : Nat) (Î£ Nat (EqualDoubleAndEven $x))))
;; ;; (: EqualDoubleAndEven (-> Nat (-> Nat Type)))
;; ;; (= ((EqualDoubleAndEven $x) $k) (âŠ— (=== $k (double $x)) (Even $k)))
;; ;; ;; Or, alternatively
;; ;; ;; (= (EqualDoubleAndEven $x) (Î» $k (Ã— (=== $k (double $x)) (Even $k))))

;; Define Nat, called â„•, with its constructors ğ™ and ğ’ to not have
;; MeTTa type checker interfere with the backward chainer
!(add-atom &kb (: â„• Type))
!(add-atom &kb (: ğ™ â„•))
!(add-atom &kb (: ğ’ (-> (: $x â„•) â„•)))

;; Define Even
!(add-atom &kb (: Even (-> (: $x â„•) Type)))
!(add-atom &kb (: MkEvenZ (Even ğ™)))
!(add-atom &kb (: MkEvenSS (-> (: $prf (Even $k))               ; Premise
                               (Even (ğ’ (: (ğ’ (: $k â„•)) â„•)))))) ; Conclusion

;; Define Î£
!(add-atom &kb
           (: MkÎ£
              (-> (: $p (-> (: $_ $a) Type)) ; Premise 1.  We
                                             ;   need to use (: $_ $a)
                                             ;   as opposed to just $a
                                             ;   to be fully consistent with
                                             ;   The (: PROOF PREMISE)
                                             ;   notation, till it becomes
                                             ;   optional.
                  (-> (: $x $a)              ; Premise 2
                      (-> (: $prf ($p $x))   ; Premise 3
                          (Î£ $a $p))))))     ; Conclusion

;; Structural induction on â„•.  TODO: remove $q.  This has been added
;; to deal with (Even (double $x)), thus $p would be Even and $q
;; double.  Instead $q should be removed and the property should be
;; expressed with combinators, like (Even . double), or lambda
;; abstractions, like (Î» z (Even (double z))).
!(add-atom &kb
           (: SIâ„•
              (-> (: $prfZ ($p ($q (: ğ™ â„•))))                    ; Premise 1.  (p . q) is true for ğ™.
                  (-> (: $prfI                                   ; Premise 2.
                         (-> (: $x â„•)                            ;   Given any natural x,
                             (-> (: $hyp ($p ($q (: $x â„•))))     ;   if (p . q) is true for x, then
                                 ($p ($q (: (ğ’ (: $x â„•)) â„•)))))) ;   it is true for (ğ’ x).
                      (-> (: $k â„•)                               ; Conclusion.  Given any natural k
                          ($p ($q (: $k â„•))))))))                ;   (p . q) is true for k.

;; Refl is disabled because it is not needed in that experiment
;;
;; ;; Equality is reflexive
;; !(add-atom &kb (: Refl (=== $x $x)))

;; Equality is transitive
!(add-atom &kb (: Trans (-> (: $prf1 (=== $x $y))     ; Premise 1
                            (-> (: $prf2 (=== $y $z)) ; Premise 2
                                (=== $x $z)))))       ; Conclusion

;; Equality is symmetric
!(add-atom &kb (: Sym (-> (: $prf (=== $x $y)) ; Premise
                          (=== $y $x))))       ; Conclusion

;; Equality respects function application
!(add-atom &kb (: Cong (-> (: $f (-> (: $_ $a) $b))                 ; Premise 1
                           (-> (: $x $a)                            ; Premise 2
                               (-> (: $x' $a)                       ; Premise 3
                                   (-> (: $prf (=== $x $x'))        ; Premise 4
                                       (=== ($f $x) ($f $x')))))))) ; Conclusion

;; Rule of replacement
!(add-atom &kb (: Replace (-> (: $prf1 (=== $x $x')) ; Premise 1
                              (-> (: $prf2 $x)       ; Premise 2
                                  $x'))))            ; Conclusion

;; Define double
!(add-atom &kb (: double (-> (: $k â„•) â„•)))
!(add-atom &kb (: double_base (=== (double (: ğ™ â„•)) ğ™)))
!(add-atom &kb (: double_rec (-> (: $k â„•)
                                 (=== (double (: (ğ’ (: $k â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: $k â„•)) â„•)) â„•))))))

;;;;;;;;;;;;;;;
;; Reduction ;;
;;;;;;;;;;;;;;;

;; Reduction rules to simplify proofs and reduce redundancy

;; TODO: these rules should be proven first.  Then they could
;; automatically be inserted.

;; ;; Involution of symmetry
;; ;; (= (Sym (Sym $f)) $f)
;; (= (: (Sym (: (Sym (: $x $a)) $b)) $c) (: $x $a))

;; ;; Involution of Trans and Sym
;; ;; (= ((Trans $x) (Sym $x)) $x)
;; ;; (= ((Trans (Sym $x)) $x) $x)
;; (= (: ((Trans (: $x $a)) (: (Sym (: $x $a)) $b)) $c) (: $x $a))
;; (= (: ((Trans (: (Sym (: $x $a)) $b)) (: $x $a)) $c) (: $x $a))

;; Identity
(= ((Î» $x $x) $y) $y)

;; Constant function
(= ((Î» (s z) z) $x) z)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Remove/add type annotation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Remove type annotation from a query.
;;
;; For instance
;;
;; (remove-type-annotation (: ((ModusPonens (: ab (â†’ A B))) (: a A)) B))
;;
;; outputs
;;
;; ((ModusPonens ab) a)
(: remove-type-annotation (-> $a $a))
(= (remove-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ;; Only covers up to trinary expression because
                    ;; for now the bc is not supposed to generate
                    ;; n-ary expression where n is greater 3.
                    ((() ())
                     (($x) ((remove-type-annotation $x)))
                     (($x $y) ((remove-type-annotation $x) (remove-type-annotation $y)))
                     (($x $y $z) (if (== $x :)
                                     (remove-type-annotation $y)
                                     ((remove-type-annotation $x)
                                      (remove-type-annotation $y)
                                      (remove-type-annotation $z))))
                     ($_ $_)))))))

;; Add type missing annotation to be compatible with bc query format.
;; Whatever is missing is only added as variables, not inferred, for
;; that one may use the bc.  Note that the first annotation must be
;; provided manually
;;
;; For instance
;;
;; (add-type-annotation ((ModusPonens ab) a))
;;
;; only outputs
;;
;; ((ModusPonens (: ab $t#1)) (: a $t#2))
;;
;; not
;;
;; (: ((ModusPonens (: ab $t#1)) (: a $t#2)) $t#3)
;;
;; That is because add-type-annotation can only detect application, that is a
;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
;;
;; TODO: must keep track of the existing type to remain consistant.
(: add-type-annotation (-> $a $a))
(= (add-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ((() ())
                     (($x) ($x))
                     (($x $y) (if (== $x s)
                                  ;; Treat De Bruijn index atomically
                                  $term
                                  ;; Add type annotation to argument of application
                                  (let $Î½x (add-type-annotation $x) ($Î½x (: (add-type-annotation $y) $t)))))
                     (($x $y $z) (if (== $x :)
                                     ;; Already a type annotation, recurse only on $y
                                     (: (add-type-annotation $y) $z)
                                     (if (== $x Î»)
                                         ;; Recurse only on body of lambda abstraction
                                         (Î» $y (add-type-annotation $z))
                                         $term)))
                     ($_ $_)))))))

;;;;;;;;;;;
;; Tests ;;
;;;;;;;;;;;

;; Synthesize natural numbers
!(assertEqualToResult
  (bc &kb Nil z (fromNumber 1) (: $prf â„•))
  ((: (ğ’ (: ğ™ â„•)) â„•)
   (: (double (: ğ™ â„•)) â„•)
   (: ğ™ â„•)))

;; Prove that 0 is even
!(assertEqual
  (bc &kb Nil z (fromNumber 0) (: $prf (Even ğ™)))
  (: MkEvenZ (Even ğ™)))

;; Prove that 2 is even
!(assertEqual
  (bc &kb Nil z (fromNumber 1) (: $prf (Even (ğ’ (: (ğ’ (: ğ™ â„•)) â„•)))))
  (: (MkEvenSS (: MkEvenZ (Even ğ™))) (Even (ğ’ (: (ğ’ (: ğ™ â„•)) â„•)))))

;; Synthesize even numbers.  With a depth of 3 it can only synthesize
;; zero.  To synthesize 2 it needs a depth of 4 but it takes 15
;; minutes.
;;
;; TODO: needs alpha equivalence
;; !(assertEqual
  !(bc &kb Nil z (fromNumber 3) (: $prf (Î£ â„• Even)))
  ;; (: (((MkÎ£ (: Even (-> (: $_ â„•) Type))) (: ğ™ â„•)) (: MkEvenZ (Even ğ™))) (Î£ â„• Even)))

;; Synthesize unary functions over natural numbers, that is
;; prove (-> (: $k â„•) â„•).
!(assertEqualToResult
  (bc &kb Nil z (fromNumber 1) (: $prf (-> (: $k â„•) â„•)))
  ((: (Î» z ğ™) (-> (: z â„•) â„•))
   (: (Î» z z) (-> (: z â„•) â„•))
   (: ğ’ (-> (: $k â„•) â„•))
   (: double (-> (: $k â„•) â„•))))

;; Synthesize endofunctions, that is prove (-> (: $x $a) $a).
;;
;; TODO: the list is too big to be listed.  Re-enable tests when we
;; have assertContain or such.
!(bc &kb Nil z (fromNumber 1) (: $prf (-> (: $x $a) $a)))

;; ;; TODO: disabled because it takes too long
;; ;; Synthesize the composition operator
;; !(bc &kb Nil z (fromNumber 4)
;;      (: $prf (-> (: $g (-> (: $y $b) $c))
;;                  (-> (: $f (-> (: $x $a) $b))
;;                      (-> (: $x $a) $c)))))

;; ;; TODO: disabled because it takes too long
;; ;; Synthesize the flip operator, that is prove
;; ;;
;; ;; (-> (: $f (-> (: $x $a) (-> (: $y $b) $c)))
;; ;;     (-> (: $y $b) (-> (: $x $a) $c)))))
;; !(bc &kb Nil z (fromNumber 5)
;;      (: $prf (-> (: $f (-> (: $x $a) (-> (: $y $b) $c)))
;;                  (-> (: $y $b) (-> (: $x $a) $c)))))

;; Prove that Even is a type constructor that takes a natural
;;
;; A possible proof of that is represented by the following proof tree:
;;
;; -----------------(Even)
;; (-> (: $_ â„•) Type)
;;
!(assertEqual
  (bc &kb Nil z (fromNumber 0) (: $prf (-> (: $_ â„•) Type)))
  (: Even (-> (: $_ â„•) Type)))

;; Verify that ğ™ is a natural
;;
;; A possible proof of that is represented by the following proof tree:
;;
;; -(ğ™)
;; â„•
;;
!(assertEqual
  (bc &kb Nil z (fromNumber 0) (: ğ™ â„•))
  (: ğ™ â„•))

;; Verify that (double ğ™) is a natural.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;;  -(ğ™)
;;  â„•
;;  -(double)
;;  â„•
;;
!(assertEqual
  (bc &kb Nil z (fromNumber 1) (: (double (: ğ™ â„•)) â„•))
  (: (double (: ğ™ â„•)) â„•))

;; Prove that ğ™ = (double ğ™).
;;
;; A possible proof of that is represented by the following proof tree:
;;
;; -----------------(double_base)
;; (=== (double ğ™) ğ™)
;; -----------------(Sym)
;; (=== ğ™ (double ğ™))
;;
;; Or in MeTTa format:
;;
;; (: (Sym double_base) (=== ğ™ (double ğ™)))
!(assertEqual
  (bc &kb Nil z (fromNumber 1) (: $prf (=== ğ™ (double (: ğ™ â„•)))))
  (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™)))
     (=== ğ™ (double (: ğ™ â„•)))))

;; ;; TODO: re-enabled once reduction works again
;; ;; Like above with depth of 3.  Used to test reduction rules.
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 3) (: $prf (=== ğ™ (double (: ğ™ â„•)))))
;;   ;; (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™)))
;;   ;;    (=== ğ™ (double (: ğ™ â„•)))))

;; Infer the theorem that (Cong Even) proves.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;; -----------------(Even)
;; (-> (: $_ â„•) Type)
;; ---------------------------------------------------------------------------------(Cong)
;; (-> (: $x â„•) (-> (: $x' â„•) (-> (: $prf (=== $x $x')) (=== (Even $x) (Even $x')))))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
!(bc &kb Nil z (fromNumber 1) (: (Cong (: Even $t)) $thrm))
  ;; (: (Cong (: Even (-> (: $_ â„•) Type)))
  ;;    (-> (: $x â„•)
  ;;        (-> (: $x' â„•)
  ;;            (-> (: $prf (=== $x $x'))
  ;;                (=== (Even $x) (Even $x'))))))

;; Infer the theorem that (Cong Even ğ™) proves.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;; -----------------(Even) -(ğ™)
;; (-> (: $_ â„•) Type)      â„•
;; -------------------------------------------------------------------(Cong)
;; (-> (: $x' â„•) (-> (: $prf (=== ğ™ $x')) (=== (Even ğ™) (Even $x'))))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
!(bc &kb Nil z (fromNumber 2) (: ((Cong (: Even $a)) (: ğ™ $b)) $thrm))
  ;; (: ((Cong (: Even (-> (: $_ â„•) Type))) (: ğ™ â„•))
  ;;    (-> (: $x' â„•)
  ;;        (-> (: $prf (=== ğ™ $x'))
  ;;            (=== (Even ğ™) (Even $x')))))

;; Infer the theorem that (Cong Even ğ™ (double ğ™)) proves.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;;                              -(ğ™)
;;                              â„•
;; -----------------(Even) -(ğ™) -(double)
;; (-> (: $_ â„•) Type)      â„•    â„•
;; -----------------------------------------------------------------(Cong)
;; (-> (: $prf (=== ğ™ (double ğ™))) (=== (Even ğ™) (Even (double ğ™))))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
!(bc &kb
     Nil
     z
     (fromNumber 3)
     (: (((Cong (: Even $a)) (: ğ™ $b)) (: (double (: ğ™ $c)) $d)) $thrm))
  ;; (: (((Cong (: Even (-> (: $_ â„•) Type))) (: ğ™ â„•)) (: (double (: ğ™ â„•)) â„•))
  ;;    (-> (: $prf (=== ğ™ (double (: ğ™ â„•))))
  ;;        (=== (Even ğ™) (Even (double (: ğ™ â„•))))))

;; Find proof of (-> (: $hyp (=== ğ™ (double ğ™))) (=== (Even ğ™) (Even (double ğ™))))
;;
;; A possible proof of that is represented by the following proof tree:
;;
;;                              -(ğ™)
;;                              â„•
;; -----------------(Even) -(ğ™) -(double)
;; (-> (: $_ â„•) Type)      â„•    â„•
;; -----------------------------------------------------------------(Cong)
;; (-> (: $hyp (=== ğ™ (double ğ™))) (=== (Even ğ™) (Even (double ğ™))))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
  !(bc &kb
      Nil
      z
      (fromNumber 3)
      (: $prf (-> (: $eq (=== ğ™ (double (: ğ™ â„•)))) (=== (Even ğ™) (Even (double (: ğ™ â„•)))))))
  ;; (: (((Cong (: Even (-> (: $_ â„•) Type))) (: ğ™ â„•)) (: (double (: ğ™ â„•)) â„•))
  ;;    (-> (: $eq (=== ğ™ (double (: ğ™ â„•))))
  ;;        (=== (Even ğ™) (Even (double (: ğ™ â„•)))))))

;; Infer the theorem that (Cong Even ğ™ (double ğ™) (Sym double_base)) proves.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;;                               -(ğ™)      -----------------(double_base)
;;                               â„•         (=== (double ğ™) ğ™)
;; -----------------(Even) -(ğ™)  -(double) -----------------(Sym)
;; (-> (: $_ â„•) Type)      â„•     â„•         (=== ğ™ (double ğ™))
;; ---------------------------------------------------------(Cong)
;;                (=== (Even ğ™) (Even (double ğ™)))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
!(bc &kb
     Nil
     z
     (fromNumber 4)
     (: ((((Cong
            (: Even $a))
           (: ğ™ $b))
          (: (double (: ğ™ $c)) $d))
         (: (Sym (: double_base $e)) $f))
        $thrm))
  ;; (: ((((Cong
  ;;        (: Even (-> (: $_ â„•) Type)))
  ;;       (: ğ™ â„•))
  ;;      (: (double (: ğ™ â„•)) â„•))
  ;;     (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
  ;;    (=== (Even ğ™) (Even (double (: ğ™ â„•)))))

;; Find the proof of (=== (Even ğ™) (Even (double (: ğ™ â„•)))) starting
;; by Cong.
;;
;; A possible proof of that is represented by the following proof tree:
;;
;;                               -(ğ™)      -----------------(double_base)
;;                               â„•         (=== (double ğ™) ğ™)
;; -----------------(Even) -(ğ™)  -(double) -----------------(Sym)
;; (-> (: $_ â„•) Type)      â„•     â„•         (=== ğ™ (double ğ™))
;; ----------------------------------------------------------(Cong)
;;                (=== (Even ğ™) (Even (double ğ™)))
;;
;; TODO: use assertEqual once we support alpha-equivalence
;; !(assertEqual
!(bc &kb
     Nil
     z
     (fromNumber 4)
     (: ((((Cong
            $prf1)
           $prf2)
          $prf3)
         $prf4)
        (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
  ;; (: ((((Cong
  ;;        (: Even (-> (: $_ â„•) Type)))
  ;;       (: ğ™ â„•))
  ;;      (: (double (: ğ™ â„•)) â„•))
  ;;     (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
  ;;    (=== (Even ğ™) (Even (double (: ğ™ â„•)))))

;; ;; TODO: disabled because it takes too long.  To make it fast one
;; ;; needs to disabled lambda abstraction.
;; ;;
;; ;; Find the proof of (=== (Even ğ™) (Even (double (: ğ™ â„•))))
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ğ™)      -----------------(double_base)
;; ;;                               â„•         (=== (double ğ™) ğ™)
;; ;; -----------------(Even) -(ğ™)  -(double) -----------------(Sym)
;; ;; (-> (: $_ â„•) Type)      â„•     â„•         (=== ğ™ (double ğ™))
;; ;; ---------------------------------------------------------(Cong)
;; ;;                (=== (Even ğ™) (Even (double ğ™)))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb
;;      Nil
;;      z
;;      (fromNumber 4)
;;      (: $prf (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
;;   ;; (: ((((Cong
;;   ;;        (: Even (-> (: $_ â„•) Type)))
;;   ;;       (: ğ™ â„•))
;;   ;;      (: (double (: ğ™ â„•)) â„•))
;;   ;;     (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
;;   ;;    (=== (Even ğ™) (Even (double (: ğ™ â„•)))))

;; Verify that
;;
;; ((Replace ((((Cong Even) ğ™) (double ğ™)) (Sym double_base))))
;;
;; proves that (double ğ™) is even, corresponding to the proof tree
;;
;;                         -(ğ™)       -----------------(double_base)
;;                         â„•          (=== (double ğ™) ğ™)
;; ----------(Even)  -(ğ™)  -(double)  -----------------(Sym)
;; (-> â„• Type)       â„•     â„•          (=== ğ™ (double ğ™))
;;  ---------------------------------------------------(Cong)  -------(MkEvenZ)
;;           (=== (Even ğ™) (Even (double ğ™)))                  (Even Z)
;; ---------------------------------------------------------------------(Replace)
;;                             (Even (double ğ™))
;;
;; TODO: use alpha-equivalence
;; !(assertAlphaEqual
  !(bc &kb
      Nil
      z
      (fromNumber 6)
      (: ((Replace
           (: ((((Cong
                  (: Even $a))
                 (: ğ™ $b))
                (: (double (: ğ™ $c)) $d))
               (: (Sym (: double_base $e)) $f))
              $h))
          (: MkEvenZ $i))
         (Even (double (: ğ™ â„•)))))
  ;; (: ((Replace
  ;;      (: ((((Cong
  ;;             (: Even (-> (: $_ â„•) Type)))
  ;;            (: ğ™ â„•))
  ;;           (: (double (: ğ™ â„•)) â„•))
  ;;          (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
  ;;         (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
  ;;     (: MkEvenZ (Even ğ™)))
  ;;    (Even (double (: ğ™ â„•)))))

;; ;; TODO: disabled because it takes too long.  To make it fast one
;; ;; needs to disabled lambda abstraction.
;; ;;
;; ;; Prove that (double ğ™) is even.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ğ™)      -----------------(double_base)
;; ;;                               â„•         (=== (double ğ™) ğ™)
;; ;; -----------------(Even) -(ğ™)  -(double) -----------------(Sym)
;; ;; (-> (: $_ â„•) Type)      â„•     â„•         (=== ğ™ (double ğ™))
;; ;; ----------------------------------------------------------(Cong)  -------(MkEvenZ)
;; ;;                (=== (Even ğ™) (Even (double ğ™)))                   (Even ğ™)
;; ;;                ----------------------------------------------------------(Replace)
;; ;;                                       (Even (double ğ™))
;; ;;
;; ;; Or in MeTTa format:
;; ;;
;; ;; (: ((Replace ((((Cong Even) ğ™) (double ğ™)) (Sym double_base))) MkEvenZ) (Even (double ğ™)))
;; ;;
;; ;; TODO: re-enable with alpha-equivalence
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 6) (: $prf (Even (double (: ğ™ â„•)))))
;;   ;; (: ((Replace
;;   ;;      (: ((((Cong
;;   ;;             (: Even (-> (: $_ â„•) Type)))
;;   ;;            (: ğ™ â„•))
;;   ;;           (: (double (: ğ™ â„•)) â„•))
;;   ;;          (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™)))
;;   ;;             (=== ğ™ (double (: ğ™ â„•)))))
;;   ;;         (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
;;   ;;     (: MkEvenZ (Even ğ™)))
;;   ;;    (Even (double (: ğ™ â„•)))))

;; Prove
;;
;; (-> (: Even (-> (: $_ â„•) Type))
;;     (-> (: (double (ğ’ $k)) â„•)
;;         (-> (: (ğ’ (ğ’ (double $k))) â„•)
;;             (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;;                 (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))))
;;
;; which should merely be Cong.
!(assertEqual
  (bc &kb Nil z (fromNumber 0)
      (: $prf (-> (: Even (-> (: $_ â„•) Type))
                  (-> (: (double (ğ’ $k)) â„•)
                      (-> (: (ğ’ (ğ’ (double $k))) â„•)
                          (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
                              (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))))))
  (: Cong (-> (: Even (-> (: $_ â„•) Type))
              (-> (: (double (ğ’ $k)) â„•)
                  (-> (: (ğ’ (ğ’ (double $k))) â„•)
                      (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
                          (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))))))

;; Prove
;;
;; (-> (: (double (ğ’ $k)) â„•)
;;     (-> (: (ğ’ (ğ’ (double $k))) â„•)
;;         (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;;             (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))))
;;
;; which should be (Cong Even).
;; TODO: re-enable after introducting assertAlphaEqual
;; !(assertEqual
  (bc &kb Nil z (fromNumber 1)
      (: $prf (-> (: (double (ğ’ $k)) â„•)
                  (-> (: (ğ’ (ğ’ (double $k))) â„•)
                      (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
                          (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))))))
  ;; (: (Cong (: Even (-> (: $_ â„•) Type)))
  ;;    (-> (: (double (ğ’ $k)) â„•)
  ;;        (-> (: (ğ’ (ğ’ (double $k))) â„•)
  ;;            (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
  ;;                (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))))))

;; Type annotate (Î» z (((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))))
;; TODO: re-enable once assertAlphaEqual is supported
;; !(assertEqual
  !(add-type-annotation (Î» z (((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z))))))
  ;; (Î» z (((Cong (: Even $a)) (: (double (: (ğ’ (: z $b)) $c)) $d)) (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h))))

;; Infer theorem of proof
;;
;; (Î» z (((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))))
;;
;; which should be
;;
;; (-> (: $k â„•)
;;     (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;;         (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))
;;
;; TODO: re-enable once assertAlphaEqual is supported
;; !(assertEqual
  !(bc &kb Nil z (fromNumber 5)
      (: (Î» z (((Cong (: Even $a)) (: (double (: (ğ’ (: z $b)) $c)) $d)) (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h)))
         $thrm))
  ;; (: (Î» z (((Cong (: Even (-> (: $_ â„•) Type))) (: (double (: (ğ’ (: z â„•)) â„•)) â„•)) (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•)))
  ;;    (-> (: z â„•)
  ;;        (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
  ;;            (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))

;; Prove
;;
;; (-> (: $k â„•)
;;     (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;;         (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))
;;
;; giving (Î» z (((Cong ...) ...) ...)) as clue, which could be
;;
;; (Î» z (((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))))
;; !(assertAlphaEqual
 !(bc &kb Nil z (fromNumber 5)
      (: (Î» z (((Cong $prf1) $prf2) $prf3))
         (-> (: z â„•)
             (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
                 (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))
  ;; (: (Î» z (((Cong (: Even (-> (: $_ â„•) Type)))
  ;;           (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
  ;;          (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•)))
  ;;    (-> (: z â„•)
  ;;        (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
  ;;            (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))

;; Prove
;;
;; (-> (: $k â„•)
;;     (-> (: Even (-> (: $_ â„•) Type))
;;         (-> (: (double (ğ’ $k)) â„•)
;;             (-> (: (ğ’ (ğ’ (double $k))) â„•)
;;                 (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;;                     (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))))))
;;
;; A possible proof could be
;;
;; (Î» $k Cong)
!(assertEqual
  (bc &kb Nil z (fromNumber 1)
      (: $prf
         (-> (: $k â„•)
             (-> (: Even (-> (: $_ â„•) Type))
                 (-> (: (double (: (ğ’ (: $k â„•)) â„•)) â„•)
                     (-> (: (ğ’ (: (ğ’ (: (double (: $k â„•)) â„•)) â„•)) â„•)
                         (-> (: $eq (=== (double (: (ğ’ (: $k â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: $k â„•)) â„•)) â„•))))
                             (=== (Even (double (: (ğ’ (: $k â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: $k â„•)) â„•)) â„•)))))))))))
  (: (Î» z Cong)
     (-> (: z â„•)
         (-> (: Even (-> (: $_ â„•) Type))
             (-> (: (double (: (ğ’ (: z â„•)) â„•)) â„•)
                 (-> (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•)
                     (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
                         (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))))))

;; Add type annotation to (Î» z ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))
;; TODO: re-enable once we have assertAlphaEqual
;; !(assertEqual
  !(add-type-annotation (Î» z ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z))))
  ;; (Î» z ((((Cong (: Even $a)) (: (double (: (ğ’ (: z $b)) $c)) $d)) (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j))))

;; ;; TODO: disabled because it takes too long.
;; ;;
;; ;; Prove
;; ;;
;; ;; (-> (: $k â„•)
;; ;;     (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;; ;;         (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))
;; ;;
;; ;; giving (Î» z ...) as clue, which could be
;; ;;
;; ;; (Î» z (((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))))
;; ;; !(assertAlphaEqual
;;   !(bc &kb Nil z (fromNumber 5)
;;        (: (Î» z $bdy)
;;           (-> (: z â„•)
;;               (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
;;                   (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))
;;   ;; (: (Î» z (((Cong (: Even (-> (: $_ â„•) Type)))
;;   ;;           (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
;;   ;;          (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•)))
;;   ;;    (-> (: z â„•)
;;   ;;        (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
;;   ;;            (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))

;; ;; TODO: disabled because it takes too long.
;; ;;
;; ;; Prove
;; ;;
;; ;; (-> (: $k â„•)
;; ;;     (-> (: $eq (=== (double (ğ’ $k)) (ğ’ (ğ’ (double $k)))))
;; ;;         (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))))
;; ;;
;; ;; which could be
;; ;;
;; ;; (Î» $k (((Cong Even) (double (ğ’ $k))) (ğ’ (ğ’ (double $k)))))
;; ;;
;; ;; TODO: re-enable once assertAlphaEqual is supported
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 5)
;;        (: $prf
;;           (-> (: z â„•)
;;               (-> (: $eq (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
;;                   (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))

;; Prove
;;
;; (-> (: z â„•)
;;     (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))
;;
;; which should merely be double_rec
!(assertEqual
  (bc &kb Nil z (fromNumber 0)
      (: $prf
         (-> (: z â„•)
             (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
  (: double_rec (-> (: z â„•) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))

;; Verify that
;;
;; (Î» z ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))
;;
;; is a proof of
;;
;; (-> (: $k â„•) (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))
!(assertEqual
  (bc &kb Nil z (fromNumber 6)
      (: (Î» z ((((Cong (: Even (-> (: $_ â„•) Type)))
                 (: (double (: (ğ’ (: z $b)) $c)) $d))
                (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h))
               (: (double_rec (: z $i)) $j)))
         (-> (: z â„•)
             (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
  (: (Î» z ((((Cong
              (: Even (-> (: $_ â„•) Type)))
             (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
            (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
           (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
     (-> (: z â„•) (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))

;; Prove
;;
;; (-> (: $k â„•) (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))
;;
;; giving (Î» z ((((Cong $prf1) $prf2) $prf3) $prf4)) as clue
;;
;; A possible proof could be
;;
;; (Î» z ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))
;;
;; Beware that this may take half an hour.
;;
!(bc &kb Nil z (fromNumber 6)
     (: (Î» z ((((Cong $prf1) $prf2) $prf3) $prf4))
        (-> (: z â„•)
            (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))

;; ;; TODO: disabled because it takes too long.
;; ;;
;; ;; Prove
;; ;;
;; ;; (-> (: $k â„•) (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k))))))
;; ;;
;; ;; giving (Î» z $bdy) as clue
;; ;;
;; ;; A possible proof could be
;; ;;
;; ;; (Î» z ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))
;; !(bc &kb Nil z (fromNumber 6)
;;      (: (Î» z $bdy)
;;         (-> (: z â„•)
;;             (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))

;; Verify that
;;
;; (Î» z (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z))))
;;
;; is a proof of
;;
;; (-> (: $k â„•) (=== (Even (ğ’ (ğ’ (double $k)))) (Even (double (ğ’ $k)))))
!(assertEqual
  (bc &kb Nil z (fromNumber 7)
      (: (Î» z (Sym (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                         (: (double (: (ğ’ (: z $b)) $c)) $d))
                        (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h))
                       (: (double_rec (: z $i)) $j)) $k)))
         (-> (: z â„•)
             (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))
  (: (Î» z (Sym (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                     (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                    (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                   (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
                  (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
     (-> (: z â„•) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))

;; Verify that
;;
;; (Î» z (Replace (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))))
;;
;; is a proof of
;;
;; (-> (: z â„•) (-> (: $e (Even (ğ’ (ğ’ (double z))))) (Even (double (ğ’ z)))))
;;
;; corresponding to the following proof tree
;;
;;                                                   -(z)
;;                                                   â„•
;;                                         -(z)      -(double)
;;                                         â„•          â„•
;;                                         -(ğ’)       -(ğ’)                      -(z)
;;                                         â„•          â„•                         â„•
;;                -----------------(Even)  -(double)  -(ğ’)  --------------------------------------(double_rec)
;;                (-> (: $_ â„•) Type)       â„•          â„•     (=== (double (ğ’ z)) (ğ’ (ğ’ (double z))))
;;                --------------------------------------------------------------------------------(Cong)
;;                (=== (Even (double (ğ’ z))) (Even (ğ’ (ğ’ (double z)))))
;;                ----------------------------------------------------(Sym)
;;                (=== (Even (ğ’ (ğ’ (double z)))) (Even (double (ğ’ z))))
;; -(z)         ----------------------------------------------------------(Replace)
;; â„•            (-> (: $e (Even (ğ’ (ğ’ (double z))))) (Even (double (ğ’ z))))
;; -----------------------------------------------------------------------(Î»)
;; (-> (: z â„•) (-> (: $e (Even (ğ’ (ğ’ (double z))))) (Even (double (ğ’ z)))))
;;
;; Before checking, let us type annotate the proof (disabled till assertAlphaEqual is support)
;; !(assertAlphaEqual
;;   (add-type-annotation (Î» z (Replace (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z))))))
;;   (Î» z (Replace (: (Sym (: ((((Cong (: Even $a)) (: (double (: (ğ’ (: z $b)) $c)) $d)) (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j)) $k)) $l))))
!(assertEqual
  (bc &kb Nil z (fromNumber 8)
      (: (Î» z
           (Replace
            (: (Sym
                (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                      (: (double (: (ğ’ (: z $b)) $c)) $d))
                     (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h))
                    (: (double_rec (: z $i)) $j))
                   $k))
               $l)))
         (-> (: z â„•) (-> (: $prf (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))
  (: (Î» z
       (Replace
        (: (Sym
            (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                  (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                 (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
               (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
           (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))
     (-> (: z â„•) (-> (: $prf (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))

;; Prove that if (double z) is even then (ğ’ (ğ’ (double z))) is even,
;; using (Î» z (Î» (s z) $bdy)) as initial proof clue.
!(assertEqual
  (bc &kb Nil z (fromNumber 3)
      (: (Î» z (Î» (s z) $bdy))
         (-> (: z â„•)
             (-> (: (s z) (Even (double (: z â„•))))
                 (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
  (: (Î» z
       (Î» (s z)
         (MkEvenSS (: (s z) (Even (double (: z â„•)))))))
     (-> (: z â„•)
         (-> (: (s z) (Even (double (: z â„•))))
             (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))

;; Remove type annotation of next proof
!(assertEqual
  (remove-type-annotation
   (: ((Replace
        (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
       (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
      (Even (double (: (ğ’ (: z â„•)) â„•)))))
  ((Replace (s (s z))) (MkEvenSS (s z))))

;; Verify that
;;
;; ((Replace (s (s z))) (MkEvenSS (s z)))
;;
;; is the proof that (double (ğ’ z)) is even, assuming that
;;
;; (: z â„•)
;; (: (s z) (Even (double z)))
;; (: (s (s (s z))) (=== (Even (ğ’ (ğ’ (double $k)))) (Even (double (ğ’ $k)))))
;;
;; The proof may correspond to the proof tree below
;;
;;                                                                    ----------------(s z)
;;                                                                    (Even (double z))
;; ----------------------------------------------------(s (s z))  ------------------------(MkEvenSS)
;; (=== (Even (ğ’ (ğ’ (double z)))) (Even (double (ğ’ z))))          (Even (ğ’ (ğ’ (double z))))
;; -----------------------------------------------------------------------------------------(Replace)
;;                                  (Even (double (ğ’ z)))
!(assertEqual
  (bc &kb
      (Cons (: z â„•)
            (Cons (: (s z) (Even (double (: z â„•))))
                  (Cons (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
                        Nil)))
      z
      (fromNumber 2)
      (: ((Replace
           (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
          (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
         (Even (double (: (ğ’ (: z â„•)) â„•)))))
  (: ((Replace
       (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
      (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
     (Even (double (: (ğ’ (: z â„•)) â„•)))))

;; Like above but the first hypothesis is wrapped in a lambda abstraction
!(assertEqual
  (bc &kb
      (Cons (: (s z) (Even (double (: z â„•))))
            (Cons (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
                        Nil))
      z
      (fromNumber 3)
      (: (Î» z
           ((Replace
             (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
            (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
         (-> (: z â„•)
             (Even (double (: (ğ’ (: z â„•)) â„•))))))
  (: (Î» z
       ((Replace
         (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
        (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
     (-> (: z â„•) (Even (double (: (ğ’ (: z â„•)) â„•))))))

;; Like above but the first 2 hypotheses are wrapped in lambda abstractions
!(assertEqual
  (bc &kb
      (Cons (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
            Nil)
      z
      (fromNumber 4)
      (: (Î» z
           (Î» (s z)
             ((Replace
               (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
              (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
         (-> (: z â„•)
             (-> (: (s z) (Even (double (: z â„•))))
                 (Even (double (: (ğ’ (: z â„•)) â„•)))))))
  (: (Î» z
       (Î» (s z)
         ((Replace
           (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
          (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
     (-> (: z â„•) (-> (: (s z) (Even (double (: z â„•)))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))

;; Like above but only the last hypothesis is wrapped in a lambda abstraction
!(assertEqual
  (bc &kb
      (Cons (: z â„•)
            (Cons (: (s z) (Even (double (: z â„•))))
                  Nil))
      (s (s z))
      (fromNumber 3)
      (: (Î» (s (s z))
           ((Replace
             (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
            (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
         (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
             (Even (double (: (ğ’ (: z â„•)) â„•))))))
  (: (Î» (s (s z))
       ((Replace (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
        (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
     (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
         (Even (double (: (ğ’ (: z â„•)) â„•))))))

;; Like above but the last 2 hypotheses are wrapped in lambda abstractions
!(assertEqual
  (bc &kb
      (Cons (: z â„•) Nil)
      (s z)
      (fromNumber 4)
      (: (Î» (s z)
           (Î» (s (s z))
             ((Replace
               (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
              (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
         (-> (: (s z) (Even (double (: z â„•))))
             (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
                 (Even (double (: (ğ’ (: z â„•)) â„•)))))))
  (: (Î» (s z)
       (Î» (s (s z))
         ((Replace (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
          (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
     (-> (: (s z) (Even (double (: z â„•))))
         (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
             (Even (double (: (ğ’ (: z â„•)) â„•)))))))

;; Like above but all hypotheses are wrapped in lambda abstractions.
;; In other words, type check that if (double z) is even, and
;;
;; (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))
;;
;; is equal to
;;
;; (Even (double (: (ğ’ (: z â„•)) â„•))))
;;
;; then (ğ’ (ğ’ (double z))) is even.
!(assertEqual
  (bc &kb
      Nil
      z
      (fromNumber 5)
      (: (Î» z
           (Î» (s z)
             (Î» (s (s z))
               ((Replace
                 (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
                (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))
         (-> (: z â„•)
             (-> (: (s z) (Even (double (: z â„•))))
                 (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
                     (Even (double (: (ğ’ (: z â„•)) â„•))))))))
  (: (Î» z
       (Î» (s z)
         (Î» (s (s z))
           ((Replace
             (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
            (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))))
     (-> (: z â„•)
         (-> (: (s z) (Even (double (: z â„•))))
             (-> (: (s (s z)) (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•)))))
                 (Even (double (: (ğ’ (: z â„•)) â„•))))))))

;; Verify that
;;
;; (Î» z (Î» (s z) ((Replace (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))) (MkEvenSS (s z)))))
;;
;; is the proof that if (double k) is even, then (double (ğ’ k)) is even, which corresponds to the tree below
;;
;;                                                                                 -(z)
;;                                                                                 â„•
;;                                                                      -(z)      -(double)
;;                                                                      â„•          â„•
;;                                                                      -(ğ’)       -(ğ’)                      -(z)
;;                                                                      â„•          â„•                         â„•
;;                                               -----------------(Even)  -(double)  -(ğ’)  --------------------------------------(double_rec)
;;                                               (-> (: $_ â„•) Type)       â„•          â„•     (=== (double (ğ’ z)) (ğ’ (ğ’ (double z))))
;;                                               ----------------------------------------------------------------------------------(Cong)  ----------------(s z)
;;                                               (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))                                   (Even (double z))
;;                                               ------------------------------------------------------(Sym)                       ------------------------(MkEvenSS)
;;                                               (=== (Even (ğ’ (ğ’ (double $k)))) (Even (double (ğ’ $k))))                           (Even (ğ’ (ğ’ (double z))))
;;              ----------------(s z)            ----------------------------------------------------------------------------------------------------------(Replace)
;;              (Even (double z))                (Even (double (ğ’ z)))
;; -(z)         -----------------------------------------------------(Î»)
;; â„•            (-> (: (s z) (Even (double z))) (Even (double (ğ’ z))))
;; ------------------------------------------------------------------(Î»)
;; (-> (: z â„•) (-> (: (s z) (Even (double z))) (Even (double (ğ’ z)))))
;;
;; Before checking, let us type annotate the proof (disabled till assertAlphaEqual is supported)
;; !(assertAlphaEqual
;;   (add-type-annotation (Î» z (Î» (s z) ((Replace (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))) (MkEvenSS (s z))))))
;;   (Î» z (Î» (s z) ((Replace (: (Sym (: ((((Cong (: Even $a)) (: (double (: (ğ’ (: z $b)) $c)) $d)) (: (ğ’ (: (ğ’ (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j)) $k)) $l)) (: (MkEvenSS (: (s z) $m)) $n)))))
!(assertEqual
  (bc &kb
      Nil
      z
      (fromNumber 10)
      (: (Î» z
           (Î» (s z)
             ((Replace
               (: (Sym
                   (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                         (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                        (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                       (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
                      (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
                  (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
              (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
         (-> (: z â„•)
             (-> (: (s z) (Even (double (: z â„•))))
                 (Even (double (: (ğ’ (: z â„•)) â„•)))))))
  (: (Î» z
       (Î» (s z)
         ((Replace
           (: (Sym
               (: ((((Cong (: Even (-> (: $_ â„•) Type)))
                     (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                    (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                   (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
                  (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
              (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
          (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
     (-> (: z â„•)
         (-> (: (s z) (Even (double (: z â„•))))
             (Even (double (: (ğ’ (: z â„•)) â„•)))))))

;; Infer theorem of
;;
;; (SIâ„• ((Replace ((((Cong Even) ğ™) (double ğ™)) (Sym double_base)))))
;; !(assertAlphaEqual
  !(bc &kb
      Nil
      z
      (fromNumber 7)
      (: (SIâ„•
          (: ((Replace
               (: ((((Cong
                      (: Even $a))
                     (: ğ™ $b))
                    (: (double (: ğ™ $c)) $d))
                   (: (Sym (: double_base $e)) $f))
                  $g))
              (: MkEvenZ $h))
             (Even (double (: ğ™ â„•)))))
         $thrm))
  ;; (: (SIâ„•
  ;;     (: ((Replace
  ;;          (: ((((Cong
  ;;                 (: Even (-> (: $_ â„•) Type)))
  ;;                (: ğ™ â„•))
  ;;               (: (double (: ğ™ â„•)) â„•))
  ;;              (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
  ;;             (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
  ;;         (: MkEvenZ (Even ğ™)))
  ;;        (Even (double (: ğ™ â„•)))))
  ;;    (-> (: $prfI (-> (: $x â„•) (-> (: $hyp (Even (double (: $x â„•)))) (Even (double (: (ğ’ (: $x â„•)) â„•)))))) (-> (: $k â„•) (Even (double (: $k â„•)))))))

;; Verify that
;;
;; ((SIâ„• ((Replace ((((Cong Even) ğ™) (double ğ™)) (Sym double_base)))))
;;  (Î» z (Î» (s z) ((Replace (Sym ((((Cong Even) (double (ğ’ z))) (ğ’ (ğ’ (double z)))) (double_rec z)))) (MkEvenSS (s z))))))
;;
;; proves that (double k) is even for any natural k, corresponding to the tree below
;;
;;                                                                                                                      -(z)
;;                                                                                                                      â„•
;;                                                                                                           -(z)       -(double)
;;                                                                                                           â„•          â„•
;;                                                                                                           -(ğ’)       -(ğ’)                     -(z)
;;                                                                                                           â„•          â„•                        â„•
;;                                                                                  -----------------(Even)  -(double)  -(ğ’)  --------------------------------------(double_rec)
;;                                                                                  (-> (: $_ â„•) Type)       â„•          â„•     (=== (double (ğ’ z)) (ğ’ (ğ’ (double z))))
;;                                                                                  --------------------------------------------------------------------------------(Cong)     ----------------(s z)
;;                                                                                                            (=== (Even (double (ğ’ $k))) (Even (ğ’ (ğ’ (double $k)))))          (Even (double z))
;;                         -(ğ™)       -----------------(double_base)                                          ------------------------------------------------------(Sym)  ------------------------(MkEvenSS)
;;                         â„•          (=== (double ğ™) ğ™)                                                      (=== (Even (ğ’ (ğ’ (double $k)))) (Even (double (ğ’ $k))))      (Even (ğ’ (ğ’ (double z))))
;; ----------(Even)  -(ğ™)  -(double)  -----------------(Sym)                           ----------------(s z)  -------------------------------------------------------------------------------------(Replace)
;; (-> â„• Type)       â„•     â„•          (=== ğ™ (double ğ™))                               (Even (double z))                (Even (double (ğ’ z)))
;; ----------------------------------------------------(Cong)  -------(MkEvenZ)  -(z)  -----------------------------------------------------(Î»)
;;           (=== (Even ğ™) (Even (double ğ™)))                  (Even Z)          â„•     (-> (: (s z) (Even (double z))) (Even (double (ğ’ z))))
;;           ---------------------------------------------------------(Replace)  ------------------------------------------------------------------(Î»)
;;                     (Even (double ğ™))                                         (-> (: z â„•) (-> (: (s z) (Even (double z))) (Even (double (ğ’ z)))))
;;                     ----------------------------------------------------------------------------------------------------------------------------(SIâ„•)
;;                                                             (-> (: $k â„•) (Even (double $k)))
!(assertEqual
  (bc &kb
      Nil
      z
      (fromNumber 11)
      (: ((SIâ„•
           (: ((Replace
                (: ((((Cong
                       (: Even (-> (: $_1 â„•) Type)))
                      (: ğ™ â„•))
                     (: (double (: ğ™ â„•)) â„•))
                    (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
                   (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
               (: MkEvenZ (Even ğ™)))
              (Even (double (: ğ™ â„•)))))
          (: (Î» z
               (Î» (s z)
                 ((Replace
                   (: (Sym
                       (: ((((Cong (: Even (-> (: $_2 â„•) Type)))
                             (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                            (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                           (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
                          (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
                      (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
                  (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
             (-> (: z â„•)
                 (-> (: (s z) (Even (double (: z â„•))))
                     (Even (double (: (ğ’ (: z â„•)) â„•)))))))
         (-> (: $k â„•) (Even (double (: $k â„•))))))
  (: ((SIâ„•
       (: ((Replace
            (: ((((Cong
                   (: Even (-> (: $_1 â„•) Type)))
                  (: ğ™ â„•))
                 (: (double (: ğ™ â„•)) â„•))
                (: (Sym (: double_base (=== (double (: ğ™ â„•)) ğ™))) (=== ğ™ (double (: ğ™ â„•)))))
               (=== (Even ğ™) (Even (double (: ğ™ â„•))))))
           (: MkEvenZ (Even ğ™)))
          (Even (double (: ğ™ â„•)))))
      (: (Î» z
           (Î» (s z)
             ((Replace
               (: (Sym
                   (: ((((Cong
                          (: Even (-> (: $_2 â„•) Type)))
                         (: (double (: (ğ’ (: z â„•)) â„•)) â„•))
                        (: (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)) â„•))
                       (: (double_rec (: z â„•)) (=== (double (: (ğ’ (: z â„•)) â„•)) (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))
                      (=== (Even (double (: (ğ’ (: z â„•)) â„•))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))))))
                  (=== (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•))) (Even (double (: (ğ’ (: z â„•)) â„•))))))
              (: (MkEvenSS (: (s z) (Even (double (: z â„•))))) (Even (ğ’ (: (ğ’ (: (double (: z â„•)) â„•)) â„•)))))))
         (-> (: z â„•) (-> (: (s z) (Even (double (: z â„•)))) (Even (double (: (ğ’ (: z â„•)) â„•)))))))
     (-> (: $k â„•) (Even (double (: $k â„•))))))
