;; Implement functions to convert terms between MeTTa, lambda calculus
;; and combinatory logic.
;;
;; For the lambda calculus <-> combinatory logic part, the code is
;; inspired from the paper:
;;
;; A correct-by-construction conversion from lambda calculus to
;; combinatory logic, by Wouter Swierstra.
;;
;; As in the paper, the version of combinatory logic in consideration
;; is S, K, I.  In order not to have S, the combinator, be confused
;; with with S, the successor, we use the unicode characters ğ’, ğŠ and
;; ğˆ, as well as other similar unicode characters for more
;; combinators.  Also all functions are explicitly curried, thus ğŠ x y
;; is represented in MeTTa as ((ğŠ x) y).
;;
;; On the lambda-calculus side, the MeTTa representation of a lambda
;; abstraction is (Î» <VAR> <BODY>).  Applications are explicitly
;; curried as well, thus (x y z) is represented ((x y) z).
;;
;; An excellent source information about combinatory logic can be
;; found in this blog series
;;
;; https://farrugiamaths.quora.com/Combinatory-logic-Using-math-boldsymbol-mathsf-S-math-and-math-boldsymbol-mathsf-K-math-Part-1
;;
;; by Alexander Farrugia
;;
;; To test if our reduction rules and convertion algorithms between
;; lambda calculus and combinatory logic are correct we use arithmetic.
;;
;; For arithmetic in combinatory logic, see
;;
;; https://farrugiamaths.quora.com/Combinatory-logic-Natural-numbers-and-predicates-Part-6
;;
;; For arithmetic in lambda calculus, see
;;
;; https://en.wikipedia.org/wiki/Lambda_calculus#Arithmetic_in_lambda_calculus

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Common functions and types ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: Z' DeBruijn)                        ; Zero
(: S' (-> DeBruijn DeBruijn))          ; Successor

;; Define Maybe type
(: Maybe (-> $a Type))
(: Nothing (Maybe $a))
(: Just (-> $a (Maybe $a)))

;; Define list type
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;; Define is-expression, a function that returns True iff the input is
;; a MeTTa expression, meaning it is not a symbol or a variable.
(: is-expression (-> Atom Bool))
(= (is-expression $x) (== (get-metatype $x) Expression))

;; Test is-expression
!(assertEqual (is-expression $x) False)
!(assertEqual (is-expression A) False)
!(assertEqual (is-expression (A B)) True)

;; Define is-variable, a function that returns True iff its input is a
;; MeTTa variable.
(: is-variable (-> Atom Bool))
(= (is-variable $x) (== (get-metatype $x) Variable))

;; Test is-variable
!(assertEqual (is-variable $x) True)
!(assertEqual (is-variable A) False)
!(assertEqual (is-variable (A $x)) False)

;; Define is-symbol, a function that returns True iff its input is a
;; MeTTa symbol.
(: is-symbol (-> Atom Bool))
(= (is-symbol $x) (== (get-metatype $x) Symbol))

;; Test is-symbol
!(assertEqual (is-symbol $x) False)
!(assertEqual (is-symbol A) True)
!(assertEqual (is-symbol (A $x)) False)

;; Till lazy or and and gets into the stdlib
(: lazy-or (-> Bool Atom Bool))
(= (lazy-or False $x) $x)
(= (lazy-or True $x) True)
(: lazy-and (-> Bool Atom Bool))
(= (lazy-and False $x) False)
(= (lazy-and True $x) $x)

;; Return True iff the first argument is a subterm of the second
;; argument.
;;
;; For instance
;;
;; (is-subterm-of A A) returns True
;; (is-subterm-of A (A B)) returns True
;; (is-subterm-of A B) returns False
;; (is-subterm-of A (B C)) returns False
;;
;; It should handle variables properly (that is assume that variables
;; with different names are different terms), for instance
;;
;; (is-subterm-of $x $x) returns True
;; (is-subterm-of $x ($x $y)) returns True
;; (is-subterm-of $x $y) returns False
;; (is-subterm-of $x ($y $z)) return False
;;
;; Terms can of course contain both symbols and variables, for
;; instance
;;
;; (is-subterm-of A ($x A)) returns True
;; (is-subterm-of $x ($x A)) returns True
;; (is-subterm-of A ($x B)) returns False
;; (is-subterm-of $x ($y A)) returns False
;;
;; It should of course detect a subterm when it is buried deeper
;; inside the superterm, for instance
;;
;; (is-subterm-of A (C (B A))) returns True
;; (is-subterm-of A (B (C D))) returns False
(: is-subterm-of (-> Atom Atom Bool))
(= (is-subterm-of $x $y)
   ;; Base cases
   (if (== $x $y)
       True
       (if (== $y ())
           False
           ;; Recursive step
           (if (is-expression $y)
               (lazy-or (let $head (car-atom $y) (is-subterm-of $x $head))
                        (let $tail (cdr-atom $y) (is-subterm-of $x $tail)))
               ;; Final base case
               False))))

;; Test is-subterm-of
!(assertEqual (is-subterm-of A A) True)
!(assertEqual (is-subterm-of A ()) False)
!(assertEqual (is-subterm-of A (A B)) True)
!(assertEqual (is-subterm-of A B) False)
!(assertEqual (is-subterm-of A (B C)) False)
!(assertEqual (is-subterm-of $x $x) True)
!(assertEqual (is-subterm-of $x ($x $y)) True)
!(assertEqual (is-subterm-of $x $y) False)
!(assertEqual (is-subterm-of $x ($y $z)) False)
!(assertEqual (is-subterm-of A ($x A)) True)
!(assertEqual (is-subterm-of $x ($x A)) True)
!(assertEqual (is-subterm-of A ($x B)) False)
!(assertEqual (is-subterm-of $x ($y A)) False)
!(assertEqual (is-subterm-of A (C (B A))) True)
!(assertEqual (is-subterm-of A (B (C D))) False)

;; Define Î±-Binding type, that represents a binding from a variable to
;; another variable.
(: Î±-Binding Type)
(: â†”Î± (-> Variable Variable Î±-Binding))

;; Insert an Î±-binding in a list of Î±-bindings.  Returns maybe the new
;; list of Î±-bindings if the insertion succeeded, that is the
;; Î±-binding is consistent with the list, or entirely missing from it.
(: Î±-insert (-> Î±-Binding (List Î±-Binding) (Maybe (List Î±-Binding))))
;; Base case
(= (Î±-insert (â†”Î± $x $y) Nil) (Just (Cons (â†”Î± $x $y) Nil)))
;; Recursive step
(= (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $z $w) $tail))
   (if (== $x $z)
       (if (== $y $w)
           (Just (Cons (â†”Î± $z $w) $tail))
           Nothing)
       (if (== $y $w)
           Nothing
           (case (Î±-insert (â†”Î± $x $y) $tail)
             ((Nothing Nothing)
              ((Just $Î½tl) (Just (Cons (â†”Î± $z $w) $Î½tl))))))))

;; Test Î±-insert
!(assertEqual
  (Î±-insert (â†”Î± $x $y) Nil)
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $x $y) Nil))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $x $z) Nil))
  Nothing)
!(assertEqual
  (Î±-insert (â†”Î± $x $y) (Cons (â†”Î± $z $w) Nil))
  (Just (Cons (â†”Î± $z $w) (Cons (â†”Î± $x $y) Nil))))

;; Join two Î±-bindings to produce an Î±-bindings consisting of the
;; union of these.  If the two Î±-bindings provided in input are
;; inconsistent, or one of them in Nothing, then return Nothing.
(: Î±-join (-> (Maybe (List Î±-Binding))
              (Maybe (List Î±-Binding))
              (Maybe (List Î±-Binding))))
;; Base cases
(= (Î±-join Nothing Nothing) Nothing)
(= (Î±-join Nothing (Just $_)) Nothing)
(= (Î±-join (Just $_) Nothing) Nothing)
(= (Î±-join (Just Nil) (Just $other)) (Just $other))
;; Recursive step
(= (Î±-join (Just (Cons $head $tail)) (Just $other))
   (Î±-join (Just $tail) (Î±-insert $head $other)))

;; Test Î±-join
!(assertEqual
  (Î±-join Nothing Nothing)
  Nothing)
!(assertEqual
  (Î±-join (Just Nil) (Just Nil))
  (Just Nil))
!(assertEqual
  (Î±-join (Just Nil) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just Nil))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just Nil) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $x $z) Nil)))
  Nothing)
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $x $y) Nil)))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-join (Just (Cons (â†”Î± $x $y) Nil)) (Just (Cons (â†”Î± $z $w) Nil)))
  (Just (Cons (â†”Î± $z $w) (Cons (â†”Î± $x $y) Nil))))

;; Given two terms, $lhs and $rhs, return maybe a list of Î±-bindings
;; so that if $lhs is Î±-equivalent to $rhs, substituting all variables
;; in $rhs according to the Î±-bindings would result in a term that is
;; equal to $lhs.  If $lhs and $rhs are not Î±-equivalent then return
;; Nothing.
(: Î±-bindings (-> Atom Atom (Maybe (List Î±-Binding))))
(= (Î±-bindings $lhs $rhs)
   (case (get-metatype $lhs)
     ((Symbol (if (== $lhs $rhs)
                  (Just Nil)
                  Nothing))
      (Grounded (if (== $lhs $rhs)
                    (Just Nil)
                    Nothing))
      (Variable (if (is-variable $rhs)
                    (Just (Cons (â†”Î± $lhs $rhs) Nil))
                    Nothing))
      (Expression (if (== $lhs ())
                      ;; $lhs is ()
                      (if (== $rhs ())
                          (Just Nil)
                          Nothing)
                      ;; $lhs is not ()
                      (if (== $rhs ())
                          Nothing
                          (case (get-metatype $rhs)
                            ((Symbol Nothing)
                             (Grounded Nothing)
                             (Variable Nothing)
                             (Expression
                              (let* (($hd-lhs (car-atom $lhs))
                                     ($tl-lhs (cdr-atom $lhs))
                                     ($hd-rhs (car-atom $rhs))
                                     ($tl-rhs (cdr-atom $rhs))
                                     ($hd-Î±-bs (Î±-bindings $hd-lhs $hd-rhs))
                                     ($tl-Î±-bs (Î±-bindings $tl-lhs $tl-rhs)))
                                (Î±-join $hd-Î±-bs $tl-Î±-bs)))))))))))

;; Test Î±-bindings
!(assertEqual
  (Î±-bindings A B)
  Nothing)
!(assertEqual
  (Î±-bindings $x B)
  Nothing)
!(assertEqual
  (Î±-bindings () ())
  (Just Nil))
!(assertEqual
  (Î±-bindings (R $x) $y)
  Nothing)
!(assertEqual
  (Î±-bindings $x $y)
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-bindings (R $x) (R $y))
  (Just (Cons (â†”Î± $x $y) Nil)))
!(assertEqual
  (Î±-bindings ((R $x) A) ((R $y) $z))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $x) ((R $z) $w))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $y) ((R $z) $z))
  Nothing)
!(assertEqual
  (Î±-bindings (R $x (R $y)) (R $z $z))
  Nothing)
!(assertEqual
  (Î±-bindings ((R $x) $y) ((R $z) $w))
  (Just (Cons (â†”Î± $y $w) (Cons (â†”Î± $x $z) Nil))))

;; Return True iff two given terms are alpha-equivalent.  For now all
;; variables are assumed to be free, the notion of scope is not
;; implemented.
(: =Î± (-> $a $b Bool))
(= (=Î± $lhs $rhs) (case (Î±-bindings $lhs $rhs)
                    ((Nothing False)
                     ((Just $_) True))))

;; Test =Î±
!(assertEqual (=Î± $x $x) True)
!(assertEqual (=Î± $x $y) True)
!(assertEqual (=Î± A B) False)
!(assertEqual (=Î± A $y) False)
!(assertEqual (=Î± (R $x) (R $y)) True)
!(assertEqual (=Î± (R $x $x) (R $y $z)) False)
!(assertEqual (=Î± (R $x (R $y)) (R $z $z)) False)
!(assertEqual (=Î± (Î» $x (Î» $y $x)) (Î» $z (Î» $w $z))) True)

;;;;;;;;;;;;;;;;;;;;;
;; Reduction rules ;;
;;;;;;;;;;;;;;;;;;;;;

;; Due to double-sided matching, combinatory logic and lambda calculus
;; reduction rules cannot be emulated that easily.  Instead a reduce
;; function is implemented instead.

;; Reduce lambda application
;; (: Î» (-> Variable $a (-> $b $c))) ; Problemantic for =Î± (no idea why)
;; (: Î» (-> Variable Atom Atom)) ; Problematic for reduction
;; (= ((Î» $x $f) $y) (let ($Î½x $Î½f) (sealed ($x) ($x $f)) (let $Î½x $y $Î½f)))

;; ;; Test lambda calculus reduction
;; !(assertEqual
;;   $x
;;   $x)
;; !(assertEqual
;;   ($f $x)
;;   ($f $x))
;; !(assertEqual
;;   (Î» $x ($f $x))
;;   (Î» $x ($f $x)))
;; !(assertEqual
;;   ((Î» $x $x) $y)
;;   $y)
;; !(assertEqual
;;   ((Î» $x $x) (Î» $x $x))
;;   (Î» $x $x))
;; !(assertEqual
;;   ((Î» $f (Î» $x $x)) $g)
;;   (Î» $x $x))
;; !(assertEqual
;;   (Î» $f (Î» $x $x))                       ; 0
;;   (Î» $f (Î» $x $x)))
;; !(assertEqual
;;   (Î» $f (Î» $x ($f $x)))                  ; 1
;;   (Î» $f (Î» $x ($f $x))))
;; !(assertEqual
;;   (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) ; Successor
;;   (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))))
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; !(assertEqual
;;   ((Î» $n (Î» $f (Î» $x (($n $x) ($f $x))))) ; ğ’
;;    (Î» $y (Î» $z (Î» $w ($y ($z $w))))))     ; ğ
;;   (Î» $f (Î» $x (Î» $w ($x (($f $x) $w)))))) ; Successor
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; ;; !(assertEqual
;; !((Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))
;;   (Î» $f (Î» $x $x))) ; 1, successor of 0
;; ;; (Î» $f (Î» $x ($f $x))))
;; ;; !(assertEqual
;; !((Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))  ; Successor
;;   ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) ; Successor
;;    (Î» $f (Î» $x $x))))                     ; 0
;; ;; (Î» $f (Î» $x ($f ($f $x)))))            ; 2, the result of (Succ (Succ 0))
;; !(assertEqual
;;   (Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
;;   (Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))))
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; ;; !(assertEqual
;;  !((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
;;    (Î» $f (Î» $x $x)))                                  ; 0
;;   ;; (Î» $n (Î» $f (Î» $x (($n $f) $x)))))  ; (Plus 0)
;; ;; !(assertEqual
;;   !(((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
;;     (Î» $f (Î» $x $x)))                                  ; 0
;;    (Î» $f (Î» $x $x)))                                   ; 0
;; ;;   (Î» $f (Î» $x $x)))  ; 0, the result of (Plus 0 0)
;; ;; !(assertEqual
;;  !(((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
;;     (Î» $f (Î» $x ($f $x))))                             ; 1
;;    (Î» $f (Î» $x ($f ($f $x)))))                         ; 2
;; ;;   (Î» $f (Î» $x ($f ($f ($f $x))))))  ; 3, the result of (Plus 1 2)

;; Reduction rules for combinatory logic.  In the process, we
;; introduce combinators ğŒ, ğ, ğ“, ğ–, ğ, ğ‚ and ğ”.
;; (= (ğˆ $x) $x)
;; (= ((ğŠ $x) $y) $x)
;; (= (((ğ’ $x) $y) $z) (($x $z) ($y $z)))
;; (= (ğŒ $x) ($x $x))
;; (= ((ğ $x) $y) $y)
;; (= ((ğ“ $x) $y) ($y $x))
;; (= ((ğ– $x) $y) (($x $y) $y))
;; (= (((ğ $x) $y) $z) ($x ($y $z)))
;; (= (((ğ‚ $x) $y) $z) (($x $z) $y))
;; (= ((ğ” $x) $y) ($y (($x $x) $y)))
;; (= ((ğ’ ğŠ) ğŠ) ğˆ)
;; (= ((ğ’ (ğŠ ğŠ)) ğˆ) ğŠ)
;; (= ((ğ’ ğˆ) ğˆ) ğŒ)
;; (= (ğŠ ğˆ) ğ)
;; (= ((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) ğ“)
;; (= ((ğ’ ğ’) ğ) ğ–)
;; (= ((ğ’ (ğŠ ğ’)) ğŠ) ğ)
;; (= ((ğ’ (ğ ğ ğ’)) (ğŠ ğŠ)) ğ‚)
;; (= ((ğ (ğ’ ğˆ)) (ğ’ ğˆ ğˆ)) ğ”)

;; ;; Test combinatory logic reduction
;; !(assertEqual
;;   (ğŠ ğˆ)                                 ; 0
;;   ğ)
;; !(assertEqual
;;   ((ğ’ (ğŠ ğŠ)) ğˆ)
;;   ğŠ)
;; !(assertEqual
;;   ((ğ’ (ğŠ ğ’)) ğŠ)
;;   ğ)
;; !(assertEqual
;;   ((ğ’ ğ’) (ğŠ ğˆ))
;;   ğ–)
;; !(assertEqual
;;   ((ğ’ ğ’) ğ)
;;   ğ–)
;; !(assertEqual
;;   (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))                    ; Successor
;;   (ğ’ ğ))
;; !(assertEqual
;;   ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ))            ; 1, as (Successor 0)
;;   ((ğ’ ğ) ğ))
;; !(assertEqual
;;   ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ))) ; 2, as (Successor (Successor 0))
;;   ((ğ’ ğ) ((ğ’ ğ) ğ)))
;; !(assertEqual
;;   (((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))) ; Plus
;;   (ğ“ (ğ’ ğ)))
;; !(assertEqual
;;   ((((ğ’ ğˆ) (ğŠ (ğ’ ğ))) ğ) ğ)             ; Apparently this is equivalent to (Plus 0 0)
;;   ğ)
;; !(assertEqual
;;   (((ğ“ (ğ’ ğ)) ğ) ğ)
;;   ğ)
;; !(assertEqual
;;   (((((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))) (ğŠ ğˆ)) (ğŠ ğˆ)) ; 0, as (Plus 0 0)
;;   ğ)
;; !(assertEqual
;;   (((((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ)))
;;    ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ)))) ; 3, as (Plus 1 2)
;;   ((ğ’ ğ) ((ğ’ ğ) ((ğ’ ğ) ğ))))

;; Reduce (ğˆ $x) to $x
(: ğˆ-reduce (-> $a (Maybe $a)))
(= (ğˆ-reduce $term)
   (case $term
     ((($i $x) (if (== $i ğˆ) (Just $x) Nothing))
      ($_ Nothing))))

;; Reduce ((ğŠ $x) $y) to $x
(: ğŠ-reduce (-> $a (Maybe $a)))
(= (ğŠ-reduce $term)
   (case $term
     (((($k $x) $y) (if (== $k ğŠ) (Just $x) Nothing))
      ($_ Nothing))))

;; Reduce (((ğ’ $x) $y) $z) to (($x $z) ($y $z))
(: ğ’-reduce (-> $a (Maybe $a)))
(= (ğ’-reduce $term)
   (case $term
     ((((($s $x) $y) $z) (if (== $s ğ’) (Just (($x $z) ($y $z))) Nothing))
      ($_ Nothing))))

;; Reduce (ğŒ $x) to ($x $x)
(: ğŒ-reduce (-> $a (Maybe $a)))
(= (ğŒ-reduce $term)
   (case $term
     ((($m $x) (if (== $m ğŒ) (Just ($x $x)) Nothing))
      ($_ Nothing))))

;; Reduce ((ğ $x) $y) to $y
(: ğ-reduce (-> $a (Maybe $a)))
(= (ğ-reduce $term)
   (case $term
     (((($n $x) $y) (if (== $n ğ) (Just $y) Nothing))
      ($_ Nothing))))

;; Reduce ((ğ“ $x) $y) to ($y $x)
(: ğ“-reduce (-> $a (Maybe $a)))
(= (ğ“-reduce $term)
   (case $term
     (((($t $x) $y) (if (== $t ğ“) (Just ($y $x)) Nothing))
      ($_ Nothing))))

;; Reduce ((ğ– $x) $y) to (($x $y) $y)
(: ğ–-reduce (-> $a (Maybe $a)))
(= (ğ–-reduce $term)
   (case $term
     (((($w $x) $y) (if (== $w ğ–) (Just (($x $y) $y)) Nothing))
      ($_ Nothing))))

;; Reduce (((ğ $x) $y) $z) to ($x ($y $z))
(: ğ-reduce (-> $a (Maybe $a)))
(= (ğ-reduce $term)
   (case $term
     ((((($b $x) $y) $z) (if (== $b ğ) (Just ($x ($y $z))) Nothing))
      ($_ Nothing))))

;; Reduce (((ğ‚ $x) $y) $z) to (($x $z) $y)
(: ğ‚-reduce (-> $a (Maybe $a)))
(= (ğ‚-reduce $term)
   (case $term
     ((((($c $x) $y) $z) (if (== $c ğ‚) (Just (($x $z) $y)) Nothing))
      ($_ Nothing))))

;; Reduce ((ğ” $x) $y) to ($y (($x $x) $y))
(: ğ”-reduce (-> $a (Maybe $a)))
(= (ğ”-reduce $term)
   (case $term
     (((($u $x) $y) (if (== $u ğ”) (Just ($y (($x $x) $y))) Nothing))
      ($_ Nothing))))

;; Reduce ((Î» $x $y) $z) to (let ($Î½x $Î½y) (sealed ($x) ($x $y)) (reduce (let $Î½x $z $Î½y)))
(: Î²-reduce (-> $a (Maybe $a)))
(= (Î²-reduce $term)
   (case $term
     (((($l $x $y) $z) (if (== $l Î») (Just (let ($Î½x $Î½y) (sealed ($x) ($x $y))
                                                (let $Î½x $z $Î½y))) Nothing))
      ($_ Nothing))))

;; Explicit reduction of combinatory logic and lambda calculus terms
;; to work around the lack of one-sided matching in reduction
(: reduce (-> $a $a))
(= (reduce $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression
       ;; Base cases
       (if (== $term ())
           ()
           (if (== $term ((ğ’ ğŠ) ğŠ))
               ğˆ
               (if (== $term ((ğ’ (ğŠ ğŠ)) ğˆ))
                   ğŠ
                   (if (== $term ((ğ’ ğˆ) ğˆ))
                       ğŒ
                       (if (== $term (ğŠ ğˆ))
                           ğ
                           (if (== $term ((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ))
                               ğ“
                               (if (== $term ((ğ’ ğ’) ğ))
                                   ğ–
                                   (if (== $term ((ğ’ (ğŠ ğ’)) ğŠ))
                                       ğ
                                       (if (== $term ((ğ’ (ğ ğ ğ’)) (ğŠ ğŠ)))
                                           ğ‚
                                           (if (== $term ((ğ (ğ’ ğˆ)) (ğ’ ğˆ ğˆ)))
                                               ğ”
                                               ;; Recursive steps
                                               (case $term
                                                 ;; Application
                                                 ((($f $g) (let* (($Î½f (reduce $f))
                                                                  ($Î½g (reduce $g)))
                                                             (if (and (== $Î½f $f) (== $Î½g $g))
                                                                 ;; $f and $g are already reduced,
                                                                 ;; try to match them to an known reduction rule
                                                                 (case (ğˆ-reduce $term)
                                                                   (((Just $r) $r)
                                                                    (Nothing
                                                                     (case (ğŠ-reduce $term)
                                                                       (((Just $r) $r)
                                                                        (Nothing
                                                                         (case (ğ’-reduce $term)
                                                                           (((Just $r) (reduce $r))
                                                                            (Nothing
                                                                             (case (ğŒ-reduce $term)
                                                                               (((Just $r) (reduce $r))
                                                                                (Nothing
                                                                                 (case (ğ-reduce $term)
                                                                                   (((Just $r) $r)
                                                                                    (Nothing
                                                                                     (case (ğ“-reduce $term)
                                                                                       (((Just $r) (reduce $r))
                                                                                        (Nothing
                                                                                         (case (ğ–-reduce $term)
                                                                                           (((Just $r) (reduce $r))
                                                                                            (Nothing
                                                                                             (case (ğ-reduce $term)
                                                                                               (((Just $r) (reduce $r))
                                                                                                (Nothing
                                                                                                 (case (ğ‚-reduce $term)
                                                                                                   (((Just $r) (reduce $r))
                                                                                                    (Nothing
                                                                                                     (case (ğ”-reduce $term)
                                                                                                       (((Just $r) (reduce $r))
                                                                                                        (Nothing
                                                                                                         (case (Î²-reduce $term)
                                                                                                           (((Just $r) (reduce $r))
                                                                                                            ;; No known reduction rule,
                                                                                                            ;; Return as it is
                                                                                                            (Nothing ($f $g))))
                                                                                                         )))
                                                                                                     )))
                                                                                                 )))
                                                                                             )))
                                                                                         )))
                                                                                     )))
                                                                                 )))
                                                                             )))
                                                                         )))
                                                                     )))
                                                                 (reduce ($Î½f $Î½g)))))
                                                  ;; Abstraction
                                                  ((Î» $x $f) (Î» $x (reduce $f)))))))))))))))))))

;; Test reduce on combinatory logic
!(assertEqual
  (reduce ğ’)
  ğ’)
!(assertEqual
  (reduce ((ğ’ (ğŠ ğŠ)) ğˆ))
  ğŠ)
!(assertEqual
  (reduce (ğŠ ğˆ))                          ; 0
  ğ)
!(assertEqual
  (reduce (ğ’ ğ’))
  (ğ’ ğ’))
!(assertEqual
  (reduce ((ğ’ (ğŠ ğ’)) ğŠ))
  ğ)
!(assertEqual
  (reduce ((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ))
  ğ“)
!(assertEqual
  (reduce ((ğ’ ğ’) (ğŠ ğˆ)))
  ğ–)
!(assertEqual
  (reduce ((ğ’ ğ’) ğ))
  ğ–)
!(assertEqual
  (reduce (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)))             ; Successor
  (ğ’ ğ))
!(assertEqual
  (reduce ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ)))     ; 1, as (Successor 0)
  ((ğ’ ğ) ğ))
!(assertEqual
  (reduce ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ)))) ; 2, as (Successor (Successor 0))
  ((ğ’ ğ) ((ğ’ ğ) ğ)))
!(assertEqual
  (reduce (ğ“ (ğ’ ğ))) ; Plus
  (ğ“ (ğ’ ğ)))
!(assertEqual
  (reduce (ğ“ (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)))) ; Plus
  (ğ“ (ğ’ ğ)))
!(assertEqual
  (reduce (((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)))) ; Plus
  (ğ“ (ğ’ ğ)))
!(assertEqual
  (reduce ((((ğ’ ğˆ) (ğŠ (ğ’ ğ))) ğ) ğ))    ; Apparently this is equivalent to (Plus 0 0)
  ğ)
!(assertEqual
  (reduce (((ğ“ (ğ’ ğ)) ğ) ğ))            ; 0, as (Plus 0 0)
  ğ)
!(assertEqual
  (reduce (((((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))) (ğŠ ğˆ)) (ğŠ ğˆ))) ; 0, as (Plus 0 0)
  ğ)
!(assertEqual
  (reduce (((((ğ’ (ğŠ (ğ’ ğˆ))) ğŠ) (ğ’ ((ğ’ (ğŠ ğ’)) ğŠ))) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ)))
           ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) ((ğ’ ((ğ’ (ğŠ ğ’)) ğŠ)) (ğŠ ğˆ))))) ; 3, as (Plus 1 2)
  ((ğ’ ğ) ((ğ’ ğ) ((ğ’ ğ) ğ))))

;; Test reduce on lambda calculus
!(assertEqual
  (reduce $x)
  $x)
!(assertEqual
  (reduce ($x $x))
  ($x $x))
!(assertEqual
  (reduce ($f $x))
  ($f $x))
!(assertEqual
  (reduce (Î» $x ($f $x)))
  (Î» $x ($f $x)))
!(assertEqual
  (reduce ((Î» $x $x) $y))
  $y)
!(assertEqual
  (reduce ((Î» $x $x) (Î» $x $x)))
  (Î» $x $x))
!(assertEqual
  (reduce ((Î» $f (Î» $x $x)) $g))
  (Î» $x $x))
!(assertEqual
  (reduce (Î» $f (Î» $x $x)))                       ; 0
  (Î» $f (Î» $x $x)))
!(assertEqual
  (reduce (Î» $f (Î» $x ($f $x))))                  ; 1
  (Î» $f (Î» $x ($f $x))))
!(assertEqual
  !(reduce (($n $f) $x)) ; Successor subsubsubsubterm
  (($n $f) $x))
!(assertEqual
  !(reduce ($f (($n $f) $x))) ; Successor subsubsubterm
  ($f (($n $f) $x)))
!(assertEqual
  !(reduce (Î» $x ($f (($n $f) $x)))) ; Successor subsubterm
  (Î» $x ($f (($n $f) $x))))
!(assertEqual
  !(reduce (Î» $f (Î» $x ($f (($n $f) $x))))) ; Successor subterm
  (Î» $f (Î» $x ($f (($n $f) $x)))))
!(assertEqual
  !(reduce (Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))) ; Successor
  (Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))))
;; NEXT: re-enable assertEqual when duplicates are fixed.
;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; !(assertEqual
!(reduce ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))
          (Î» $f (Î» $x $x)))) ; 1, successor of 0
;; (Î» $f (Î» $x ($f $x))))
;; !(assertEqual
!(reduce ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))  ; Successor
          ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) ; Successor
           (Î» $f (Î» $x $x)))))                    ; 0
;; (Î» $f (Î» $x ($f ($f $x)))))  ; 2, the result of (Succ (Succ 0))
!(assertEqual
  (reduce (Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x))))))) ; Plus
  (Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))))
;; NEXT: re-enable assertEqual when duplicates are fixed.
;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
!(assertEqual
  (reduce (((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
            (Î» $f (Î» $x $x)))                                  ; 0
           (Î» $f (Î» $x $x))))                                  ; 0
  (Î» $f (Î» $x $x)))  ; 0, the result of (Plus 0 0)
!(assertEqual
  (reduce (((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
            (Î» $f (Î» $x ($f $x))))                             ; 1
           (Î» $f (Î» $x ($f ($f $x))))))                        ; 2
  (Î» $f (Î» $x ($f ($f ($f $x))))))  ; 3, the result of (Plus 1 2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Combinatory logic to Î»-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert combinatory logic to lambda-calculus
(: cl2lc (-> $a $a))
;; Base cases
(= (cl2lc $term)
   (case (get-metatype $term)
     ((Symbol (case $term
                ((ğˆ (Î» $x $x))
                 (ğŠ (Î» $x (Î» $y $x)))
                 (ğ’ (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
                 (ğŒ (Î» $x ($x $x)))
                 (ğ (Î» $x (Î» $y $y)))
                 (ğ“ (Î» $x (Î» $y ($y $x))))
                 (ğ– (Î» $x (Î» $y (($x $y) $y))))
                 (ğ (Î» $x (Î» $y (Î» $z ($x ($y $z))))))
                 (ğ‚ (Î» $x (Î» $y (Î» $z (($x $z) $y)))))
                 (ğ” (Î» $x (Î» $y ($y (($x $x) $y)))))
                 ($_ $term))))
      (Variable $term)
      (Grounded $term)
      (Expression (if (== $term ())
                      ()
                      (case $term
                        ((($f $g) ((cl2lc $f) (cl2lc $g)))
                         ($_ $term))))))))

;; Test cl2lc
!(assertEqual
  (=Î± (cl2lc ğ) (Î» $f (Î» $x $x)))       ; 0
  True)
!(assertEqual
  (=Î± (cl2lc (ğ’ ğ))
      ((Î» $n (Î» $f (Î» $x (($n $x) ($f $x))))) ; ğ’
       (Î» $y (Î» $z (Î» $w ($y ($z $w)))))))    ; ğ
  True)
!(assertequal
  (=Î± (reduce (cl2lc (ğ’ ğ)))
      (Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))) ; Successor
  True)
!(assertEqual
  (=Î± (reduce (cl2lc ((ğ’ ğ) ğ)))                      ; (Succ 0)
      (reduce ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))  ; Successor
               (Î» $f (Î» $x $x)))))                     ; 0
  True)
!(assertEqual
  (=Î± (reduce (cl2lc ((ğ’ ğ) ğ)))       ; (Succ 0)
      (Î» $f (Î» $x ($f $x))))            ; 1, as (Succ 0)
  True)
!(assertEqual
  (=Î± (reduce (cl2lc (((ğ“ (ğ’ ğ)) ğ) ğ)))  ; (Plus 0 0)
      (Î» $f (Î» $x $x)))                     ; 0
  True)
!(assertEqual
  (=Î± (reduce (cl2lc (((ğ“ (ğ’ ğ)) ((ğ’ ğ) ğ)) ((ğ’ ğ) ((ğ’ ğ) ğ))))) ; (Plus 1 2)
      (Î» $f (Î» $x ($f ($f ($f $x))))))                              ; 3
  True)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Î»-calculus to combinatory logic ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert lambda-calculus to combinatory logic
(: lc2cl (-> Atom Number Atom Atom))
(= (lc2cl $term $cnt $dir)
   (if (is-expression $term)
       (if (== $term ())
           ;; Base cases
           (trace! (bas-âˆ… (term $term) (cnt $cnt) (dir $dir)) ())
           ;; Recursive steps
           (case $term
             (((Î» $x $f)
               (if (is-variable $x)
                   (if (== $f $x)
                       ;; Base case
                       (trace! (bas-I (term $term) (cnt $cnt) (dir $dir)) ğˆ)
                       ;; Recursive steps
                       (let $clf (lc2cl $f (+ 1 $cnt) Î»C)
                         (if (is-subterm-of $x $f)
                             ; Build ğ’
                             (trace! (rec-S (term $term) (clf $clf) (cnt $cnt) (dir $dir))
                                     (if (is-expression $clf)
                                         (case $clf
                                           ((($g $h) ((ğ’ (lc2cl (Î» $x $g) (+ 2 $cnt) Î»L))
                                                      (lc2cl (Î» $x $h) (+ 2 $cnt) Î»R)))
                                                ($_ (empty))))
                                         $clf))
                             ; Build ğŠ
                             (trace! (rec-K (term $term) (clf $clf) (cnt $cnt) (dir $dir))
                                     (ğŠ $clf)))))
                   (empty)))
              (($f $g) (trace! (rec-app (term $term) (cnt $cnt) (dir $dir))
                               ((lc2cl $f (+ 1 $cnt) L) (lc2cl $g (+ 1 $cnt) R)))))))
           (trace! (bas-nch (term $term) (cnt $cnt) (dir $dir)) $term)))

;; ;; Convert lambda-calculus to combinatory logic
;; (: lc2cl (-> Atom Number Atom Atom))
;; (= (lc2cl $term $cnt $dir)
;;    (if (is-expression $term)
;;        (if (== $term ())
;;            ;; Base cases
;;            (trace! (bas-âˆ… (term $term) (cnt $cnt) (dir $dir)) ())
;;            ;; NEXT: try to get rid of as many base cases as possible
;;            (if (=Î± $term (Î» $x $x))
;;                (trace! (bas-I (term $term) (cnt $cnt) (dir $dir)) ğˆ)
;;                (if (=Î± $term (Î» $x (Î» $y $x)))
;;                    (trace! (bas-K (term $term) (cnt $cnt) (dir $dir)) ğŠ)
;;                    (if (=Î± $term (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
;;                        (trace! (bas-S (term $term) (cnt $cnt) (dir $dir)) ğ’)
;;                        (if (=Î± $term (Î» $x ($x $x)))
;;                            (trace! (bas-M (term $term) (cnt $cnt) (dir $dir)) ğŒ)
;;                            ;; Recursive steps
;;                            (case $term
;;                              (((Î» $x $f)
;;                                (if (is-variable $x)
;;                                    (let $clf (lc2cl $f (+ 1 $cnt) Î»C)
;;                                      (if (is-subterm-of $x $f)
;;                                          ; Build ğ’
;;                                          (trace! (rec-S (term $term) (clf $clf) (cnt $cnt) (dir $dir))
;;                                          (if (is-expression $clf)
;;                                              (case $clf
;;                                                ((($g $h) ((ğ’ (lc2cl (Î» $x $g) (+ 2 $cnt) Î»L))
;;                                                           (lc2cl (Î» $x $h) (+ 2 $cnt) Î»R)))
;;                                                 ($_ (empty))))
;;                                              $clf))
;;                                          ; Build ğŠ
;;                                          (trace! (rec-K (term $term) (clf $clf) (cnt $cnt) (dir $dir))
;;                                          (ğŠ $clf))))
;;                                    (empty)))
;;                               (($f $g) (trace! (rec-app (term $term) (cnt $cnt) (dir $dir))
;;                                        ((lc2cl $f (+ 1 $cnt) L) (lc2cl $g (+ 1 $cnt) R)))))))))))
;;        (trace! (bas-nch (term $term) (cnt $cnt) (dir $dir)) $term)))

;; NEXT: add tests on remaining individual combinators

;; Test lc2cl
!(assertEqual
  (lc2cl $f 0 C)
  $f)
!(assertEqual
  (lc2cl ($f $x) 0 C)
  ($f $x))
!(assertEqual
  (lc2cl ($f ($f $x)) 0 C)
  ($f ($f $x)))
!(assertEqual
  (lc2cl (Î» $x $x) 0 C)
  ğˆ)
!(assertEqual
  (lc2cl (Î» $x (Î» $y $x)) 0 C)
  ğŠ)
!(assertEqual
  (lc2cl (Î» $f (Î» $g (Î» $x (($f $x) ($g $x))))))
  ğ’)
!(assertEqual
  (lc2cl (Î» $x ($x $x)))
  ğŒ)
!(assertEqual
  (lc2cl (Î» $x $f))
  (ğŠ $f))
!(assertEqual
  (lc2cl (Î» $x ($f $g)))
  (ğŠ ($f $g)))
;; NEXT: make sure that spontaneous reduction is not impoverishing the comparison.
!(assertEqual
  (lc2cl (Î» $f (Î» $x $x)))       ; 0
  ğ)
!(assertEqual
  (lc2cl (Î» $n (Î» $f (Î» $x ($f (($n $f) $x)))))) ; Successor
  (ğ’ ğ))
!(assertEqual
  (lc2cl ((Î» $n (Î» $f (Î» $x ($f (($n $f) $x))))) ; Successor
          (Î» $f (Î» $x $x))))                     ; 0
  ((ğ’ ğ) ğ))
!(assertEqual
  (lc2cl (Î» $f (Î» $x ($f $x))))            ; 1, as (Succ 0)
  ((ğ’ ğ) ğ))
!(assertEqual
  (lc2cl (((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
           (Î» $f (Î» $x $x)))                                  ; 0
          (Î» $f (Î» $x $x))))                                  ; 0
  (((ğ“ (ğ’ ğ)) ğ) ğ))
!(assertEqual
  (lc2cl (((Î» $m (Î» $n (Î» $f (Î» $x (($m $f) (($n $f) $x)))))) ; Plus
           (Î» $f (Î» $x ($f $x))))                             ; 1
          (Î» $f (Î» $x ($f ($f $x))))))                        ; 2
  (((ğ“ (ğ’ ğ)) ((ğ’ ğ) ğ)) ((ğ’ ğ) ((ğ’ ğ) ğ))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa to Î»-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert metta to lambda calculus with De Bruijn indices.  It takes
;; in arguments
;;
;; 1. De Bruijn index to use for the next abstraction
;;
;; 2. MeTTa term.  Built-in operators such as let must be previously
;;    converted into LET to avoid spontaneous reduction.  NEXT: maybe
;;    we actually don't.
(: mt2lc (-> DeBruijn Atom Atom))
(= (mt2lc $idx $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    (;; Empty
                     (() ())
                     ;; LET
                     ((LET $x $y $f) (let* (($x $idx)
                                            ($Î½f (mt2lc (S' $idx) $f))
                                            ($Î½y (mt2lc $idx $y)))
                                       ((Î» $x $Î½f) $Î½y)))
                     ;; Application
                     (($f $x) ((mt2lc $idx $f) (mt2lc $idx $x)))
                     ;; Other
                     ($term $term)))))))

!(assertEqual
  (mt2lc Z' (LET $x (inc 1) (plus $x $x)))
  ((Î» Z' (plus Z' Z')) (inc 1)))
